import numpy as np
from tabulate import tabulate
import matplotlib.pyplot as plt


N = 50
a = 0
b = np.pi
h = (b - a) / N
x = np.linspace(a, b, N + 1)

# Граничные условия
y0 = 0.0
yN = 1.0


# ------------------------------------------------------------------------
# A — матрица коэффициентов СЛАУ, b_vec — правая часть.
#
# Почему вообще возникает матрица:
# Метод конечных разностей заменяет дифференциальное уравнение y''−y=cos(x)
# на систему линейных уравнений для значений y_n = y(x_n).
# Каждая строка матрицы — это разностная аппроксимация уравнения в узле x_n.
# ------------------------------------------------------------------------
A = np.zeros((N + 1, N + 1))
b_vec = np.zeros(N + 1)


# Граничные условия
A[0, 0] = 1
b_vec[0] = y0

A[N, N] = 1
b_vec[N] = yN

# Внутренние узлы — СХЕМА 4-ГО ПОРЯДКА ДЛЯ y''
#
# Используем 5-точечную формулу:
# y''(x_n) ≈ [-y_{n-2} + 16y_{n-1} - 30y_n + 16y_{n+1} - y_{n+2}] / (12 h^2)
#
# Подставляем в уравнение y'' - y = cos(x_n):
#
#   [-y_{n-2} + 16y_{n-1} - 30y_n + 16y_{n+1} - y_{n+2}] / (12h^2)  - y_n = cos(x_n)

for n in range(2, N - 1):
    A[n, n - 2] = -1 / (12 * h**2)
    A[n, n - 1] = 16 / (12 * h**2)
    A[n, n]    = -30 / (12 * h**2) - 1
    A[n, n + 1] = 16 / (12 * h**2)
    A[n, n + 2] = -1 / (12 * h**2)

    b_vec[n] = np.cos(x[n])   # Правая часть уравнения в точке x_n


# Узлы 1 и N−1 не имеют соседей n−2 или n+2.
# Поэтому 4-й порядок здесь невозможен.
#
# Используем классическую трёхточечную аппроксимацию 2-го порядка:
# y''(x_n) ≈ (y_{n-1} - 2y_n + y_{n+1}) / h^2
#
# Подставляем в уравнение y'' - y = cos(x):
# (y_{n-1} - 2y_n + y_{n+1})/h^2  - y_n = cos(x_n)

A[1, 0] = 1/h**2
A[1, 1] = -2/h**2 - 1
A[1, 2] = 1/h**2
b_vec[1] = np.cos(x[1])

A[N-1, N-2] = 1/h**2
A[N-1, N-1] = -2/h**2 - 1
A[N-1, N]   = 1/h**2
b_vec[N-1] = np.cos(x[N-1])

# Решаем систему линейных уравнений A y = b.
y_num = np.linalg.solve(A, b_vec)



# =====================================================================================
#  АНАЛИТИЧЕСКОЕ РЕШЕНИЕ
# -------------------------------------------------------------------------------------
# Уравнение y'' - y = cos(x) имеет общее решение:
#
#   y(x) = C1 * e^x + C2 * e^(-x) - 1/2 * cos(x)
# Чтобы найти C1 и C2, подставляем граничные условия:
#
# y(0) = C1 + C2 - 1/2 = 0
# y(π) = C1 e^π + C2 e^{-π} + 1/2 = 1
#
# Эти два уравнения образуют систему для C1 и C2:
#
#   [1      1     ] [C1] = [y0 + 0.5*cos(0)]
#   [e^π   e^{-π} ] [C2]   [yN + 0.5*cos(π)]


A_mat = np.array([[1, 1],
                  [np.exp(np.pi), np.exp(-np.pi)]])

rhs = np.array([
    y0 + 0.5 * np.cos(0),
    yN + 0.5 * np.cos(np.pi)
])

C1, C2 = np.linalg.solve(A_mat, rhs)



def y_exact(x):
    return C1 * np.exp(x) + C2 * np.exp(-x) - 0.5 * np.cos(x)



# Точное решение
x_dense = np.linspace(a, b, 2000)
y_dense = y_exact(x_dense)

# Точное решение в узлах численной сетки
y_true = y_exact(x)



#  ТАБЛИЦА ОШИБОК
errors = np.abs(y_true - y_num)

table = []
for i in range(len(x)):
    table.append([f"{x[i]:.3f}", f"{y_num[i]:.6f}", f"{y_true[i]:.6f}", f"{errors[i]:.2e}"])

print("\nСравнение численного и аналитического решения:")
print(tabulate(table, headers=["x", "y числ.", "y точное", "ошибка"], tablefmt="github"))



#  ГРАФИКИ
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 8), sharex=True) # type: ignore

ax1.plot(x_dense, y_dense, label="Аналитическое решение", linewidth=2)
ax1.plot(x, y_num, 'o-', label="Численное (4-й порядок)", markersize=4)
ax1.set_ylabel("y")
ax1.set_title("Сравнение численного и аналитического решения")
ax1.grid(True)
ax1.legend()

ax2.plot(x, errors, 'r--', linewidth=2)
ax2.set_xlabel("x")
ax2.set_ylabel("Ошибка")
ax2.set_title("График ошибки |y_exact − y_num|")
ax2.grid(True)

plt.tight_layout()
plt.show()
